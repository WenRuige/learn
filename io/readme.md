#### i/o


`epoll`是`linux`内核为处理大批量文件描述符而设计的`i/o`复用机制,它能显著的提高,程序存在大量并发链接而只有少部分活跃链接情况下系统CPU使用率
`epoll`之所以可以做到如此高的效率,因为它在获取就绪事件的时候,并不会遍历所有被监听文件描述符集,而只会遍历那些被设备`i/o`事件异步唤醒而加入就绪链表的文件描述符集




`epoll`提供了三个系统调用给用户态程序
- `epoll_create()`
- `epoll_ctl()`
- `epoll_wait()`










`epoll` 速度快的原理,epoll 实际上也需要循环遍历,不过循环遍历的是已经ready的fd,而不是向select或者poll需要遍历所有的fd


`epoll`的触发模式:

* LT(level trigger):水平触发
* ET(edge trigger):边缘触发


LT模式下,只要内核缓冲区还有未读数据,就会返回描述符的就绪状态,不断的唤醒应用进程

ET模式下,缓冲区从不可读变成可读,会唤醒应用进程,缓冲区数据变少情况,不会在唤醒应用进程





##### 水平触发

* 对于读操作:只要缓冲区内容不为空,则返回读就绪
* 对于写操作:只要缓冲区还未满,则返回写就绪


##### 边缘触发

对于读操作:
* 当缓冲区由不可读编程可读,既缓冲区由空变成非空
* 当有新数据到达的时候,既缓冲区数据变多的时候
* TBD



对于写操作:
* 当缓冲区由不可写变成可写操作的时候
* 当有旧数据被发送走,缓冲区变少的情况
* TBD




[参考](https://blog.csdn.net/lihao21/article/details/67631516)

