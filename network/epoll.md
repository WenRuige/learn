#### 内核接受网络数据过程



* 进程在`recv`阻塞期间,计算机收到了对端传送的数据
* 数据经由网卡传送到内存
* 网卡通过中断信号通知`cpu`有数据到达,`cpu`执行中断程序
* 先把内存的数据写到socket缓冲区
* 唤醒进程



> 操作系统如何知道网络数据对应哪个`socket`






> `tcp`长连接 & keepAlive机制

长连接和短连接

##### 短连接:

每次通信时,创建`socket`,一次通信结束,调用`socket.close()`,短连接的好处是管理简单,存在的链接都是可用的链接

##### 长连接:

每次通信完毕时,不会关闭连接,这样可以做到连接的复用,长连接的好处是省去了创建连接的耗时.

##### 长连接的应用
长连接常常被用于数据的推送,大多数时候对于数据的认知还是`request/response`模型,但是`tcp`全双工通信决定了它可以用来进行双向通信

##### 连接的包活 `KeepAlive`

`keepAlive`不是`tcp`协议的一部分,



##### Notice:http keepalive和 tcp keepalive

* http keepAlive 意图在于连接复用,同一个连接上串行传递请求-响应数据
* tcp keepAlive 机制意图在于保活/心跳/检测连接错误




> 为什么都说I/O慢,慢在哪里(短连接的缺点)

* tcp 握手时延
* 延迟确认
* tcp 慢启动算法(起初会限制连接的最大速度,如果数据传输成功,会随着时间的推移提高传输速度,这种协调称为tcp慢启动)







[参考文档](https://caofengbin.github.io/2018/03/16/dhcp-and-nat/)





